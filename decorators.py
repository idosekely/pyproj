from functools import wrapsfrom multiprocessing import Processfrom multiprocessing.pool import ThreadPoolfrom multiprocessing import Queueimport timedef threaded(timeout=None):    thread = ThreadPool(processes=1)    def decorator(func):        @wraps(func)        def wrapper(*args, **kwargs):            t = thread.apply_async(func, args=args, kwds=kwargs)            return t.get(timeout)        return wrapper    return decoratordef processed(timeout=None):    def decorator(func):        queue = Queue(1)        def execute(f, *args, **kwargs):            try:                queue.put(f(*args, **kwargs))            except Exception as e:                queue.put(e)        @wraps(func)        def wrapper(*args, **kwargs):            args = (func, ) + args            p = Process(target=execute, args=args, kwargs=kwargs)            p.start()            p.join(timeout)            return queue.get()        return wrapper    return decoratordef scheduled(period, delay=None, loop_count=None):    delay = delay or 0    loop_count = loop_count or 0    def decorator(func):        @wraps(func)        def wrapper(*args, **kwargs):            counter = 0            time.sleep(delay)            while True:                start = time.time()                if loop_count and loop_count > 0:                    if counter == loop_count:                        break                    counter += 1                func(*args, **kwargs)                run_time = time.time() - start                if run_time < period:                    time.sleep(period - run_time)        return wrapper    return decoratorif __name__ == '__main__':    @threaded()    def test1(x):        time.sleep(x)        return "test 1"    @processed()    def test2(x):        time.sleep(x)        return "test 2"    @scheduled(period=3, loop_count=2)    def test3():        print "test 3"    print test1(2)    print test2(1)    test3()